<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Bookshelf Editor</title>
    <style>
        body { font-family: "Minecraft Seven", sans-serif; background-color: #2b2b2b; color: #dcdcdc; display: flex; gap: 20px; padding: 20px; margin: 0; }
        .panel { background-color: #3c3f41; border: 1px solid #555; border-radius: 8px; padding: 15px; box-sizing: border-box; display: flex; flex-direction: column; }
        #main-panel { flex: 1; min-width: 350px; }
        #detail-panel { flex: 2; }
        h1, h2 { border-bottom: 2px solid #555; padding-bottom: 5px; margin-top: 0; }
        .table-container { overflow-y: auto; flex-grow: 1; max-height: 500px; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #555; padding: 8px; text-align: left; }
        th { background-color: #45494a; position: sticky; top: 0; }
        tbody tr { cursor: pointer; }
        tbody tr:hover { background-color: #4a4e50; }
        tbody tr.selected { background-color: #0d6efd; color: white; }
        #status { margin-top: 10px; font-style: italic; color: #aaa; flex-shrink: 0; }
        #book-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; }
        #book-list li { background-color: #45494a; margin-bottom: 10px; border-radius: 5px; padding: 10px; position: relative; }
        .book-title { cursor: pointer; font-weight: bold; color: #58a6ff; }
        .book-title:hover { text-decoration: underline; }
        .book-content { display: none; margin-top: 10px; padding: 10px; background-color: #2b2b2b; border-radius: 4px; white-space: pre-wrap; max-height: 300px; overflow-y: auto; border: 1px solid #555; }
        .tab-container { display: flex; margin-bottom: 15px; }
        .tab { padding: 10px 20px; background-color: #45494a; border: 1px solid #555; cursor: pointer; margin-right: 5px; border-radius: 4px 4px 0 0; }
        .tab.active { background-color: #0d6efd; color: white; }
        .tab-content { display: none; }
        .tab-content.active { display: flex; flex-direction: column; flex-grow: 1; }
        .search-box { width: 100%; padding: 8px; margin-bottom: 10px; background-color: #2b2b2b; border: 1px solid #555; color: #dcdcdc; border-radius: 4px; }
        .inventory-type-selector { margin-bottom: 10px; }
        .inventory-type-selector label { margin-right: 15px; }
        .player-info { background-color: #45494a; padding: 10px; border-radius: 4px; margin-bottom: 10px; }
        .online-indicator { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 5px; }
        .online { background-color: #28a745; }
        .offline { background-color: #dc3545; }
        .connection-status { position: fixed; top: 10px; right: 10px; padding: 5px 10px; border-radius: 4px; font-size: 12px; }
        .connected { background-color: #28a745; color: white; }
        .disconnected { background-color: #dc3545; color: white; }
        .reconnecting { background-color: #ffc107; color: black; }
        .last-seen { font-size: 0.8em; color: #aaa; }

        /* NEW/MODIFIED STYLES FOR EDITING */
        .edit-btn { position: absolute; top: 10px; right: 10px; padding: 4px 8px; font-size: 12px; background-color: #58a6ff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        .edit-btn:hover { background-color: #2986e2; }
        .edit-form { margin-top: 10px; display: flex; flex-direction: column; gap: 10px; }
        .edit-form input, .edit-form textarea { width: 100%; box-sizing: border-box; padding: 8px; background-color: #2b2b2b; border: 1px solid #555; color: #dcdcdc; border-radius: 4px; }
        .edit-form textarea { min-height: 200px; resize: vertical; }
        .edit-form-actions { display: flex; gap: 10px; justify-content: flex-end; }
        .edit-form-actions button { padding: 6px 12px; border: none; border-radius: 4px; cursor: pointer; }
        .save-btn { background-color: #28a745; color: white; }
        .save-btn:hover { background-color: #218838; }
        .cancel-btn { background-color: #6c757d; color: white; }
        .cancel-btn:hover { background-color: #5a6268; }
        .edit-status { font-size: 0.9em; color: #ffc107; }
        .delete-btn {
            position: absolute;
            top: 10px;
            right: 60px; /* Adjusted for lock button */
            padding: 4px 8px;
            font-size: 12px;
            background-color: #dc3545; /* Red for delete */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .delete-btn:hover {
            background-color: #c82333;
        }
        .lock-btn {
            position: absolute;
            top: 10px;
            right: 100px; /* Positioned left of the delete button */
            padding: 4px 8px;
            font-size: 12px;
            background-color: #ffc107; /* Yellow for lock/unlock */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .lock-btn:hover {
            background-color: #e0a800;
        }
        .lock-btn.locked {
            background-color: #6f42c1; /* Purple when locked */
        }
        .lock-btn.locked:hover {
            background-color: #5632a5;
        }
        /* green + Add Book button */
        .btn-success {
            background-color: #28a745;
            border: 1px solid #28a745;
            color: #fff;
            padding: 4px 10px;
            font-size: 13px;
            border-radius: 4px;
            cursor: pointer;
        }
        .btn-success:hover {
            background-color: #218838;
        }
        /* blue ▶ Reorder button */
        .reorder-btn {
            background-color: #17a2b8;   /* teal-blue */
            border: 1px solid #17a2b8;
            color: #fff;
            padding: 4px 8px;
            font-size: 12px;
            border-radius: 4px;
            cursor: pointer;
        }
        .reorder-btn:hover { background-color: #138496; }
        /* â”€â”€â”€â”€â”€ BOOK EDITOR OVERLAY â”€â”€â”€â”€â”€ */
        .editor-overlay{
            position:fixed; inset:0;
            background:#000a;              /* translucent backdrop */
            display:flex; align-items:center; justify-content:center;
            z-index:9999;
        }
        .editor-window{
            width:600px; max-width:95%;
            background:#3c3f41; border:1px solid #555; border-radius:8px;
            padding:20px; box-sizing:border-box; display:flex; flex-direction:column; gap:12px;
        }
        .editor-close{
            position:absolute; top:8px; right:12px;
            background:none; border:none; font-size:26px; color:#dcdcdc; cursor:pointer;
        }
        .page-controls{display:flex; gap:6px; align-items:center;}
        .page-controls button{padding:2px 8px; cursor:pointer;}
        .format-toolbar{display:flex; flex-wrap:wrap; gap:6px;}
        .format-toolbar select,
        .format-toolbar button{padding:4px 6px; cursor:pointer; font-size:13px;}
        @font-face {
            font-family: "Minecraft Seven";
            src: url("font/Minecraft-Seven_v2.woff2") format("woff2");
            font-weight: normal;
            font-style: normal;
        }
        .editor-window,
        #editor-page,
        .book-display {
            font-family: "Minecraft Seven", monospace;
            font-size: 20px;          /* new – larger glyphs */
        }
        #editor-preview {
            width: 114px;
            height: 280px;              /* 14 lines at 20px each */
            border: 1px solid #555;
            padding: 4px;
            background: #2b2b2b;
            white-space: normal;
            overflow-wrap: normal;
        }





    </style>
</head>
<body>

<div class="connection-status reconnecting" id="connection-status">Connecting...</div>

<div id="main-panel" class="panel">
    <h1>Book Browser</h1>

    <div class="tab-container">
        <div class="tab active" data-tab="players">Players</div>
        <div class="tab" data-tab="bookshelves">Bookshelves</div>
    </div>

    <!-- Players Tab -->
    <div id="players-tab" class="tab-content active">
        <h2>Player List</h2>
        <input type="text" id="player-search" class="search-box" placeholder="Search for player...">
        <div class="inventory-type-selector">
            <label><input type="radio" name="inventory-type" value="INVENTORY" checked> Inventory</label>
            <label><input type="radio" name="inventory-type" value="ENDERCHEST"> Ender Chest</label>
        </div>

        <div class="table-container">
            <table id="player-table">
                <thead>
                <tr><th>Player</th><th>Status</th><th>Last Seen</th></tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
        <div id="player-status">Loading players...</div>
    </div>

    <!-- Bookshelves Tab -->
    <div id="bookshelves-tab" class="tab-content">
        <h2>Chiseled Bookshelves</h2>
        <div class="table-container">
            <table id="bookshelf-table">
                <thead>
                <tr><th>World</th><th>X</th><th>Y</th><th>Z</th><th></th></tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
        <div id="bookshelf-status">Loading...</div>
    </div>


</div>

<div id="detail-panel" class="panel">
    <h2 id="detail-header">Select an item to view details</h2>
    <!-- green + button for bookshelves -->
    <button id="add-book-btn" class="btn-success" style="display:none;">＋‹ Add Book</button>

    <!-- green + button shown when a player is selected -->
    <button id="add-player-book-btn" class="btn-success" style="display:none;">＋ Add Book</button>

    <ul id="book-list"></ul>
    <!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ BOOK EDITOR OVERLAY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <div id="book-editor-overlay" class="editor-overlay" style="display:none">
        <div class="editor-window">
            <button id="editor-close" class="editor-close">×</button>
            <h3 id="editor-header">Edit Book</h3>

            <label>Title:
                <input id="editor-title" type="text">
            </label>

            <label>Author:
                <input id="editor-author" type="text">
            </label>

            <!-- page navigation -->
            <div class="page-controls">
                <button id="prev-page">«</button>
                <span id="page-indicator">Page 1 / 1</span>
                <button id="next-page">»</button>
            </div>

            <!-- page editor -->
            <textarea id="editor-page" rows="10"></textarea>
            <pre id="editor-preview" class="book-display"></pre>

            <!-- Minecraft formatting toolbar -->
            <div id="format-toolbar" class="format-toolbar">
                <select id="color-picker">
                    <option value="">Color –</option>
                    <option value="§0">Black (§0)</option>
                    <option value="§1">Dark Blue (§1)</option>
                    <option value="§2">Dark Green (§2)</option>
                    <option value="§3">Dark Aqua (§3)</option>
                    <option value="§4">Dark Red (§4)</option>
                    <option value="§5">Dark Purple (§5)</option>
                    <option value="§6">Gold (§6)</option>
                    <option value="§7">Gray (§7)</option>
                    <option value="§8">Dark Gray (§8)</option>
                    <option value="§9">Blue (§9)</option>
                    <option value="§a">Green (§a)</option>
                    <option value="§b">Aqua (§b)</option>
                    <option value="§c">Red (§c)</option>
                    <option value="§d">Light Purple (§d)</option>
                    <option value="§e">Yellow (§e)</option>
                    <option value="§f">White (§f)</option>
                </select>

                <button data-code="§l">Bold</button>
                <button data-code="§o">Italic</button>
                <button data-code="§n">Underline</button>
                <button data-code="§m">Strike</button>
                <button data-code="§k">Obfusc.</button>
                <button data-code="§r">Reset</button>
            </div>

            <div class="edit-form-actions">
                <button id="editor-save" class="save-btn">Save</button>
            </div>
        </div>
    </div>
</div>


<script>
    // Global variables
    const connectionStatus = document.getElementById('connection-status');
    const detailHeader = document.getElementById('detail-header');
    const bookList = document.getElementById('book-list');
    let currentSelectedRow = null;
    let socket = null;
    let reconnectAttempts = 0;
    let currentEmptyShelfSlots = [];
    const maxReconnectAttempts = 5;

    // Player functionality
    const playerSearch = document.getElementById('player-search');
    const playerTableBody = document.querySelector("#player-table tbody");
    const playerStatus = document.querySelector("#player-status");
    const addPlayerBtn = document.getElementById('add-player-book-btn');

    // Bookshelf functionality
    const bookshelfTableBody = document.querySelector("#bookshelf-table tbody");
    const bookshelfStatus = document.querySelector("#bookshelf-status");


    let allPlayers = [];


    // Tab functionality
    document.querySelectorAll('.tab').forEach(tab => {
        addPlayerBtn.style.display = 'none';
        tab.addEventListener('click', () => {
            const tabName = tab.dataset.tab;
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            tab.classList.add('active');
            document.getElementById(tabName + '-tab').classList.add('active');
            switch(tabName) {
                case 'players': loadPlayers(); break;
                case 'bookshelves': loadBookshelves(); break;
            }
        });
    });

    // WebSocket functionality
    function connectWebSocket() {
        if (socket && socket.readyState === WebSocket.OPEN) return;
        updateConnectionStatus('reconnecting', 'Connecting...');
        socket = new WebSocket(`ws://${window.location.host}/api/live-updates`);
        socket.onopen = () => {
            console.log("WebSocket connection established.");
            updateConnectionStatus('connected', 'Connected');
            reconnectAttempts = 0;
        };
        socket.onmessage = (event) => {
            try {
                const msg = JSON.parse(event.data);
                handleWebSocketMessage(msg);
            } catch (e) {
                console.error("Error parsing WebSocket message:", e);
            }
        };
        socket.onclose = () => {
            console.log("WebSocket connection closed.");
            updateConnectionStatus('disconnected', 'Disconnected');
            if (reconnectAttempts < maxReconnectAttempts) {
                reconnectAttempts++;
                updateConnectionStatus('reconnecting', `Reconnecting... (${reconnectAttempts}/${maxReconnectAttempts})`);
                setTimeout(connectWebSocket, 5000);
            } else {
                updateConnectionStatus('disconnected', 'Connection Failed');
            }
        };
        socket.onerror = (error) => {
            console.error("WebSocket error:", error);
            updateConnectionStatus('disconnected', 'Connection Error');
        };
    }

    function updateConnectionStatus(status, text) {
        connectionStatus.className = `connection-status ${status}`;
        connectionStatus.textContent = text;
    }

    function handleWebSocketMessage(msg) {
        switch (msg.type) {
            case 'bookshelf-added':
                addBookshelfTableRow(msg.data);
                sortBookshelfTable();
                updateBookshelfStatusText();
                break;
            case 'bookshelf-removed':
                removeBookshelfRow(msg.data);
                break;
            case 'bookshelf-updated':
                handleBookshelfUpdate(msg.data);
                break;
            case 'player-status-updated':
                onPlayerStatus(msg.data);
                break;
            case 'player-list-updated':
                renderPlayerTable(msg.data);  // For simplicity, just reload players on any player update
                break;
            case 'player-book-updated':
                handlePlayerBookUpdate(msg.data);
                break;
        }
    }

    /* ---------- small JSON POST helper ----------- */
    async function postJson(url, body) {
        const r = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
        });
        if (!r.ok) {
            const err = await r.json().catch(() => ({ error: r.statusText }));
            throw new Error(err.error || 'Server error');
        }
        return r.json();
    }


    // Player functionality
    async function loadPlayers() {
        playerStatus.textContent = 'Loading players...';
        try {
            const response = await fetch('/api/players');
            const players = await response.json();
            allPlayers = players;
            displayPlayers(players);
            playerStatus.textContent = `Loaded ${players.length} players`;
        } catch (error) {
            playerStatus.textContent = `Error loading players: ${error.message}`;
        }
    }

    function displayPlayers(players) {
        playerTableBody.innerHTML = '';
        players.forEach(player => {
            const row = playerTableBody.insertRow();
            row.dataset.playerName = player.name;
            row.dataset.playerUuid = player.uuid;
            const onlineStatus = player.online ? 'Online' : 'Offline';
            const lastSeen = player.online ? 'Now' : formatLastSeen(player.lastSeen);
            row.innerHTML = `<td>${player.name}</td><td><span class="online-indicator ${player.online ? 'online' : 'offline'}"></span>${onlineStatus}</td><td class="last-seen">${lastSeen}</td>`;
            row.addEventListener('click', () => handlePlayerRowClick(player, row));
        });
    }

    function handlePlayerRowClick(player, row) {
        if (currentSelectedRow) currentSelectedRow.classList.remove('selected');
        row.classList.add('selected');
        currentSelectedRow = row;
        const inventoryType = document.querySelector('input[name="inventory-type"]:checked').value;
        loadPlayerBooks(player.name, inventoryType, player.uuid, player.online);
        document.getElementById('add-book-btn').style.display = 'none';

        addPlayerBtn.style.display = 'inline-block';
    }

    async function loadPlayerBooks(playerName, inventoryType, playerUuid, isOnline) {
        detailHeader.textContent = `Loading ${playerName}'s ${inventoryType.toLowerCase()}...`;
        bookList.innerHTML = '<li>Loading books...</li>';
        try {
            const response = await fetch(`/api/player/books?player=${encodeURIComponent(playerName)}&type=${inventoryType}`);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const books = await response.json();
            detailHeader.textContent = `Books in ${playerName}'s ${inventoryType.charAt(0) + inventoryType.slice(1).toLowerCase()} (${books.length})`;
            displayBooks(books, { playerName, inventoryType, playerUuid, isOnline }); // Pass player details to enable editing
        } catch (error) {
            detailHeader.textContent = `Error loading books for ${playerName}`;
            bookList.innerHTML = `<li>Error loading books: ${error.message}</li>`;
        }
    }

    async function handlePlayerBookUpdate(data) {
        if (currentSelectedRow && currentSelectedRow.dataset.playerName === data.playerName) {
            const inventoryType = document.querySelector('input[name="inventory-type"]:checked').value;
            await loadPlayerBooks(data.playerName, inventoryType, currentSelectedRow.dataset.playerUuid);
        }


    }

    playerSearch.addEventListener('input', debounce(() => {
        const searchTerm = playerSearch.value.toLowerCase();
        const filteredPlayers = allPlayers.filter(p => p.name.toLowerCase().includes(searchTerm));
        displayPlayers(filteredPlayers);
        playerStatus.textContent = `Showing ${filteredPlayers.length} of ${allPlayers.length} players`;
    }, 300));

    document.querySelectorAll('input[name="inventory-type"]').forEach(radio => {
        radio.addEventListener('change', () => {
            if (currentSelectedRow && currentSelectedRow.dataset.playerName) {
                const playerName = currentSelectedRow.dataset.playerName;
                const playerUuid = currentSelectedRow.dataset.playerUuid;
                const inventoryType = document.querySelector('input[name="inventory-type"]:checked').value;
                loadPlayerBooks(playerName, inventoryType, playerUuid);
            }
        });
    });

    // Bookshelf functionality
    async function loadBookshelves() {
        try {
            const response = await fetch('/api/bookshelves');
            const data = await response.json();
            bookshelfTableBody.innerHTML = '';
            data.forEach(addBookshelfTableRow);
            sortBookshelfTable();
            updateBookshelfStatusText();
        } catch (error) {
            bookshelfStatus.textContent = `Error fetching bookshelf list: ${error.message}`;
        }
    }

    function addBookshelfTableRow(shelf) {
        const row = bookshelfTableBody.insertRow();
        row.id = `shelf-${shelf.world}-${shelf.x}-${shelf.y}-${shelf.z}`;
        row.dataset.world = shelf.world;
        row.dataset.x = shelf.x;
        row.dataset.y = shelf.y;
        row.dataset.z = shelf.z;

        // â”€â”€ four coordinate cells â”€â”€
        row.innerHTML =
            `<td>${shelf.world}</td>` +
            `<td>${shelf.x}</td>` +
            `<td>${shelf.y}</td>` +
            `<td>${shelf.z}</td>` +
            `<td><button class="reorder-btn">▶ Reorder</button></td>`;

        // make row selectable
        row.addEventListener('click', () => handleBookshelfRowClick(row));

        // stop the row-select click when the button itself is pressed
        row.querySelector('.reorder-btn').addEventListener('click', e => {
            e.stopPropagation();                 // keep row from being selected
            openReorderDialog(row.dataset);      // launch prompt â†’ API call
        });
    }


    function sortBookshelfTable() {
        const rows = Array.from(bookshelfTableBody.querySelectorAll('tr'));
        rows.sort((a, b) => {
            const dsA = a.dataset, dsB = b.dataset;
            return dsA.world.localeCompare(dsB.world) || dsA.x - dsB.x || dsA.y - dsB.y || dsA.z - dsB.z;
        });
        rows.forEach(row => bookshelfTableBody.appendChild(row));
    }

    function updateBookshelfStatusText() {
        bookshelfStatus.textContent = `Showing ${bookshelfTableBody.rows.length} bookshelves`;
    }

    async function handleBookshelfRowClick(row, isAutoUpdate = false) {
        if (!isAutoUpdate) {
            if (currentSelectedRow) currentSelectedRow.classList.remove('selected');
            row.classList.add('selected');
            currentSelectedRow = row;
        }
        const { world, x, y, z } = row.dataset;
        detailHeader.textContent = `Books in Bookshelf [${world}, ${x}, ${y}, ${z}]`;
        await loadBookshelfBooks({ world, x, y, z });
        document.getElementById('add-book-btn').style.display = 'inline-block';
        addPlayerBtn.style.display = 'none';
    }

    async function openReorderDialog(loc) {
        const answer = prompt(
            'Enter the new order for slots 0-5, comma-separated.\n' +
            'Example –"5,4,3,2,1,0" reverses the shelf.',
            ''
        );
        if (answer === null) return;                       // user cancelled

        const parts = answer.split(',').map(s => +s.trim());
        const isValid = parts.length === 6 &&
            parts.every(n => n >= 0 && n <= 5) &&
            new Set(parts).size === 6;

        if (!isValid) { alert('Invalid order – must be six distinct numbers 0-5.'); return; }

        try {
            await postJson('/api/bookshelf/reorder', {
                world : loc.world,
                x     : +loc.x,
                y     : +loc.y,
                z     : +loc.z,
                newOrder : parts            // <- backend expects List<Integer>
            });
            // refresh the detail view if this shelf is currently open
            if (currentSelectedRow &&
                currentSelectedRow.dataset.world === loc.world &&
                currentSelectedRow.dataset.x     === loc.x &&
                currentSelectedRow.dataset.y     === loc.y &&
                currentSelectedRow.dataset.z     === loc.z) {
                handleBookshelfRowClick(currentSelectedRow, true);
            }
            alert('Bookshelf reordered successfully!');
        } catch (err) {
            alert('Reorder failed: ' + err.message);
        }
    }


    async function loadBookshelfBooks(location) {
        bookList.innerHTML = '<li>Loading books...</li>';
        try {
            const { world, x, y, z } = location;
            const response = await fetch(`/api/bookshelf?world=${world}&x=${x}&y=${y}&z=${z}`);
            if (!response.ok) throw new Error((await response.json()).error || `HTTP error! status: ${response.status}`);
            const books = await response.json();
            displayBooks(books, location); // Pass location to enable editing
        } catch (error) {
            bookList.innerHTML = `<li>Error loading books: ${error.message}</li>`;
        }
    }

    function removeBookshelfRow(shelf) {
        const rowId = `shelf-${shelf.world}-${shelf.x}-${shelf.y}-${shelf.z}`;
        const rowToRemove = document.getElementById(rowId);
        if (rowToRemove) {
            if (rowToRemove === currentSelectedRow) {
                currentSelectedRow = null;
                detailHeader.textContent = 'Select an item to view details';
                bookList.innerHTML = '';
            }
            rowToRemove.remove();
            updateBookshelfStatusText();
        }
    }

    function handleBookshelfUpdate(data) {
        if (currentSelectedRow && currentSelectedRow.dataset.world === data.world &&
            currentSelectedRow.dataset.x == data.x &&
            currentSelectedRow.dataset.y == data.y &&
            currentSelectedRow.dataset.z == data.z) {
            handleBookshelfRowClick(currentSelectedRow, true);
        }
    }




    // *** NEW/MODIFIED BOOK DISPLAY AND EDITING LOGIC ***

    function displayBooks(books, location = null) {
        // ----- calculate empty slots (0–5) -----
        const used = books.map(b => b.slot);          // slots that have a book
        currentEmptyShelfSlots = [];
        for (let i = 0; i < 6; i++) {
            if (!used.includes(i)) currentEmptyShelfSlots.push(i);
        }

        /* --------- build the visual list --------- */
        bookList.innerHTML = '';
        if (books.length === 0) {
            bookList.innerHTML = '<li>No books found.</li>';
        }

        /* â”€â”€ determine once whether we are editing a bookshelf or player inventory â”€â”€ */
        const bookType = location
            ? (location.world ? 'bookshelf' : 'player')
            : null;


        books.forEach(book => {
            const li = document.createElement('li');
            li.dataset.slot = book.slot;

            const bookDisplay = document.createElement('div');
            bookDisplay.className = 'book-display';
            bookDisplay.innerHTML = `<span class="book-title"></span> by <em></em> (Slot: ${book.slot})<div class="book-content"></div>`;

            const titleEl = bookDisplay.querySelector('.book-title');
            const authorEl = bookDisplay.querySelector('em');
            const contentEl = bookDisplay.querySelector('.book-content');

            titleEl.textContent = book.virtualTitle || book.title || 'Untitled';
            authorEl.textContent = book.virtualAuthor || book.author || 'Unknown';
            contentEl.textContent = book.pages.join('\n\n');

            if (!book.title && book.virtualTitle) {
                titleEl.textContent = book.virtualTitle;
                titleEl.style.fontStyle = 'italic';
            }
            if (!book.author && book.virtualAuthor) {
                authorEl.textContent = book.virtualAuthor;
                authorEl.style.color = '#aaaaaa';
            }

            li.addEventListener('click', () => openBookEditor(book, location, bookType));


            li.appendChild(bookDisplay);

            if (location) {

                // Delete button
                const deleteButton = document.createElement('button');
                deleteButton.className = 'delete-btn';
                deleteButton.textContent = '🗑️';
                deleteButton.addEventListener('click', () => handleDelete(book.slot, location, bookType, li));
                li.appendChild(deleteButton);

                // Lock/Unlock button with improved type detection
                console.log(`Book in slot ${book.slot} has type: ${book.type}`); // Debug log
                const lockButton = document.createElement('button');
                lockButton.className = 'lock-btn';
                const isLocked = book.type === 'WRITTEN_BOOK' || book.type === 'minecraft:written_book';
                lockButton.textContent = isLocked ? '🔓 Unlock' : '🔒 Lock';
                if (isLocked) lockButton.classList.add('locked');
                lockButton.addEventListener('click', () => handleLockUnlock(book.slot, location, bookType, li, isLocked));
                li.appendChild(lockButton);
            }

            bookList.appendChild(li);
        });
    }





    function showEditForm(li, book, location, type) {
        const bookDisplay = li.querySelector('.book-display');
        const editButton = li.querySelector('.edit-btn');
        bookDisplay.style.display = 'none';
        if (editButton) editButton.style.display = 'none';

        const form = document.createElement('form');
        form.className = 'edit-form';
        form.innerHTML = `
            <label>Title: <input type="text" name="title" value="${book.title || ''}"></label>
            <label>Author: <input type="text" name="author" value="${book.author || ''}"></label>
            <label>Pages (one page per line): <textarea name="pages">${book.pages.join('\n') || ''}</textarea></label>
            <div class="edit-form-actions">
                <span class="edit-status"></span>
                <button type="button" class="cancel-btn">Cancel</button>
                <button type="submit" class="save-btn">Save</button>
            </div>
        `;


        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            const saveBtn = form.querySelector('.save-btn');
            const statusEl = form.querySelector('.edit-status');
            saveBtn.disabled = true;
            statusEl.textContent = 'Saving...';

            const formData = new FormData(form);
            const pages = formData.get('pages').split('\n').filter(page => page.trim() !== '');
            let payload;
            let endpoint;

            if (type === 'bookshelf') {
                payload = {
                    ...location,
                    slot: book.slot,
                    title: formData.get('title'),
                    author: formData.get('author'),
                    pages: pages
                };
                endpoint = '/api/bookshelf/book/edit';
            } else if (type === 'player') {
                payload = {
                    playerName: location.playerName,
                    slot: book.slot,
                    title: formData.get('title'),
                    author: formData.get('author'),
                    pages: pages,
                    inventoryType: location.inventoryType
                };
                endpoint = '/api/player/book/edit';
            }

            try {
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.error || 'Failed to save book.');
                }

                statusEl.textContent = 'Saved successfully!';
                setTimeout(() => {
                    // Reload the appropriate content after save
                    if (type === 'bookshelf') {
                        handleBookshelfRowClick(currentSelectedRow, true);
                    } else if (type === 'player') {
                        loadPlayerBooks(location.playerName, location.inventoryType, location.playerUuid, location.isOnline);
                    }
                }, 1000);

            } catch (error) {
                statusEl.textContent = `Error: ${error.message}`;
                saveBtn.disabled = false;
            }
        });

        form.querySelector('.cancel-btn').addEventListener('click', () => {
            form.remove();
            bookDisplay.style.display = 'block';
            if (editButton) editButton.style.display = 'block';
        });

        li.appendChild(form);
    }

    async function handleDelete(slot, location, type, li) {
        if (!confirm('Are you sure you want to delete this book? This action cannot be undone.')) {
            return;
        }

        let endpoint = '';
        let body = {};

        if (type === 'bookshelf') {
            endpoint = '/api/bookshelf/book/delete';
            body = {
                world: location.world,
                x: parseInt(location.x),
                y: parseInt(location.y),
                z: parseInt(location.z),
                slot: slot
            };
        } else if (type === 'player') {
            endpoint = '/api/player/book/delete';
            body = {
                playerName: location.playerName,
                slot: slot,
                inventoryType: location.inventoryType
            };
        }

        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });

            if (!response.ok) {
                const err = await response.json();
                throw new Error(err.error || 'Failed to delete book.');
            }

            // Remove the book item from the UI immediately
            li.remove();

            // Refresh the book list after a short delay to sync with server
            setTimeout(() => {
                if (type === 'bookshelf') {
                    handleBookshelfRowClick(currentSelectedRow, true);
                } else if (type === 'player') {
                    loadPlayerBooks(location.playerName, location.inventoryType, location.playerUuid, location.isOnline);
                }
            }, 500);

            alert('Book deleted successfully!');
        } catch (error) {
            alert(`Error deleting book: ${error.message}`);
        }
    }


    async function handleLockUnlock(slot, location, type, li, isLocked) {
        if (!confirm(`Are you sure you want to ${isLocked ? 'unlock' : 'lock'} this book?`)) {
            return;
        }

        let endpoint = '';
        let body = {};

        if (type === 'bookshelf') {
            endpoint = isLocked ? '/api/bookshelf/book/unlock' : '/api/bookshelf/book/lock';
            body = {
                world: location.world,
                x: parseInt(location.x),
                y: parseInt(location.y),
                z: parseInt(location.z),
                slot: slot
            };
        } else if (type === 'player') {
            endpoint = isLocked ? '/api/player/book/unlock' : '/api/player/book/lock';
            body = {
                playerName: location.playerName,
                slot: slot,
                inventoryType: location.inventoryType
            };
        } else {
            console.error('Invalid type for lock/unlock:', type);
            alert('Error: Invalid book location type.');
            return;
        }

        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });

            if (!response.ok) {
                const err = await response.json();
                throw new Error(err.error || `Failed to ${isLocked ? 'unlock' : 'lock'} book.`);
            }

            // Force reload of the book list to detect new type
            if (type === 'bookshelf') {
                await loadBookshelfBooks(location); // Reload entire list
            } else if (type === 'player') {
                await loadPlayerBooks(location.playerName, location.inventoryType, location.playerUuid, location.isOnline);
            }

            alert(`Book ${isLocked ? 'unlocked' : 'locked'} successfully!`);
        } catch (error) {
            console.error('Lock/Unlock error:', error);
            alert(`Error: ${error.message}`);
        }
    }


    // Utility functions
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => { clearTimeout(timeout); func(...args); };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    function formatLastSeen(timestamp) {
        if (!timestamp) return 'Never';
        const now = Date.now();
        const diff = now - timestamp;
        const minutes = Math.floor(diff / 60000);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);
        if (minutes < 1) return 'Just now';
        if (minutes < 60) return `${minutes}m ago`;
        if (hours < 24) return `${hours}h ago`;
        return `${days}d ago`;
    }

    /* ---------- + Add Book for a bookshelf ---------- */
    document.getElementById('add-book-btn').addEventListener('click', async () => {
        if (!currentSelectedRow || !currentSelectedRow.dataset.world) return;   // no shelf selected

        /* ---------- choose a target slot ---------- */
        if (currentEmptyShelfSlots.length === 0) {
            alert('This bookshelf is full.');
            return;
        }

        let slot = currentEmptyShelfSlots[0];                 // auto-pick if only one free
        if (currentEmptyShelfSlots.length > 1) {
            const answer = prompt(
                'Empty slots: ' + currentEmptyShelfSlots.join(', ') +
                '\nWhich slot should receive the new book?', slot
            );
            if (answer === null) return;                      // cancelled
            slot = parseInt(answer, 10);
            if (!currentEmptyShelfSlots.includes(slot)) {
                alert('That slot is not empty. Aborting.');
                return;
            }
        }

        /* ---------- optional metadata ---------- */
        const title  = prompt('Title (optional):', '')        ?? '';
        const author = prompt('Author (optional):', '')       ?? '';
        const pagesRaw = prompt('Pages – put \\n between pages', '') ?? '';
        const pages  = pagesRaw.split('\\n').filter(p => p.trim() !== '');

        /* ---------- send request ---------- */
        const loc = currentSelectedRow.dataset;               // world,x,y,z
        try {
            await postJson('/api/bookshelf/book/add', {
                world: loc.world,
                x: +loc.x, y: +loc.y, z: +loc.z,
                slot,           // <-- specific empty slot
                title, author, pages
            });
            handleBookshelfRowClick(currentSelectedRow, true); // refresh panel
        } catch (e) {
            alert('Add failed: ' + e.message);
        }
    });


    /* ---------- + Add Book for a player inventory ---------- */
    document.getElementById('add-player-book-btn').addEventListener('click', async () => {
        if (!currentSelectedRow || !currentSelectedRow.dataset.playerName) return; // no player selected
        const playerName    = currentSelectedRow.dataset.playerName;
        const inventoryType = document.querySelector('input[name="inventory-type"]:checked').value;
        const title  = prompt('Title (optional):', '');
        const author = prompt('Author (optional):', '');
        const pages  = prompt('Pages: put \\n between pages', '').split('\\n').filter(p => p.trim() !== '');
        try {
            await postJson('/api/player/book/add', {
                playerName, inventoryType,
                title, author, pages
            });
            // refresh view
            loadPlayerBooks(playerName, inventoryType, currentSelectedRow.dataset.playerUuid);
        } catch (e) { alert('Add failed: ' + e.message); }
    });

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ BOOK EDITOR SCRIPT â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ pixel-perfect line layout â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    const LINE_PX   = 114;          // max width of one rendered line
    const MAX_LINES = 14;           // lines visible on one page

    /* advance widths from the wikis Font table – Java 1.21.4 */
    const MC_ADV = {
        " ":4,"!":2,'"':4,"#":6,"$":6,"%":6,"&":6,"'":2,"(":4,")":4,
        "*":4,"+":6,",":2,"-":6,".":2,"/":6,
        "0":6,"1":6,"2":6,"3":6,"4":6,"5":6,"6":6,"7":6,"8":6,"9":6,
        ":":2,";":2,"<":5,"=":6,">":5,"?":6,"@":7,
        "A":6,"B":6,"C":6,"D":6,"E":6,"F":6,"G":6,"H":6,"I":4,"J":6,
        "K":6,"L":6,"M":6,"N":6,"O":6,"P":6,"Q":6,"R":6,"S":6,"T":6,"U":6,"V":6,"W":6,"X":6,"Y":6,"Z":6,
        "[":4,"\\":6,"]":4,"^":6,"_":6,"`":3,
        "a":6,"b":6,"c":6,"d":6,"e":6,"f":5,"g":6,"h":6,"i":2,"j":6,"k":5,"l":3,"m":6,"n":6,"o":6,"p":6,"q":6,
        "r":6,"s":6,"t":4,"u":6,"v":6,"w":6,"x":6,"y":6,"z":6,
        "{":4,"|":2,"}":4,"~":7,"§":0,"\n":0
    };

    const MC_COL = {
        '0':'#000000','1':'#0000aa','2':'#00aa00','3':'#00aaaa','4':'#aa0000','5':'#aa00aa','6':'#ffaa00','7':'#aaaaaa',
        '8':'#555555','9':'#5555ff','a':'#55ff55','b':'#55ffff','c':'#ff5555','d':'#ff55ff','e':'#ffff55','f':'#ffffff'
    };

    /* width of a glyph – bold adds +1 px except on space */
    function glyphPx(ch, bold){              // â† inclusive of tracking
        const base = MC_ADV[ch] ?? 6;          // unknown glyphs = 6 px
        return base + (bold && ch!==" " ? 1 : 0);
    }

    /* count how many lines the page would consume */
    function pageLines(text){
        let lines = 1, px = 0, bold = false;
        let wrapPos = -1, wrapLine = 1, wrapPx = 0;

        for(let i=0;i<text.length;i++){
            let c = text[i];

            /* § formatting codes – zero width, may toggle bold */
            if(c==="§" && i+1<text.length){
                const code = text[i+1].toLowerCase();
                if(code==="l") bold = true;                       // bold on
                else if(code==="r" || /[0-9a-fo]/.test(code)) bold = false;
                i++; continue;
            }

            if(c==="\n"){ lines++; px=0; continue; }            // hard break

            const w = glyphPx(c,bold);

            /* remember last space for smart wrapping */
            if(c===" "){ wrapPos=i; wrapLine=lines; wrapPx=px; }

            if(px + w > LINE_PX){                              // needs wrap
                if(wrapPos>=0 && wrapLine===lines){              // wrap at space
                    i = wrapPos;           // â† rewind so next loop starts *after* the space
                    wrapPos = -1;          // forget this space
                    lines++; px = 0;       // fresh line, nothing rendered yet
                }else{                   // word itself is wider than a line
                    lines++; px = w;       // start new line with this glyph
                }
            }else{ px += w; }
            if(lines > MAX_LINES) return lines;                // early abort
        }
        return lines;
    }

    const editor = {
        overlay : document.getElementById('book-editor-overlay'),
        close   : document.getElementById('editor-close'),
        header  : document.getElementById('editor-header'),
        title   : document.getElementById('editor-title'),
        author  : document.getElementById('editor-author'),
        pageBox : document.getElementById('editor-page'),
        pageLbl : document.getElementById('page-indicator'),
        prevBtn : document.getElementById('prev-page'),
        nextBtn : document.getElementById('next-page'),
        saveBtn : document.getElementById('editor-save'),
        preview : document.getElementById('editor-preview'),
        colorPick: document.getElementById('color-picker'),
        toolbar : document.getElementById('format-toolbar'),
        state   : {}      // slot, pages[], idx, location, type
    };

    /* open the overlay */
    function openBookEditor(book, location, type){
        editor.state = {
            slot : book.slot,
            pages: [...book.pages],              // clone
            idx  : 0,
            location, type
        };
        editor.header.textContent = `Edit slot ${book.slot}`;
        editor.title.value  = book.title  ?? '';
        editor.author.value = book.author ?? '';
        showCurrentPage();
        editor.overlay.style.display = 'flex';

        editor.pageBox.dataset.prev = editor.pageBox.value;     // snapshot
        enforceLimit();

    }


    function enforceLimit(){
        const box = editor.pageBox;

        if(pageLines(box.value) > MAX_LINES){
            box.value = box.dataset.prev;                      // revert overflow
            box.selectionStart = box.selectionEnd = box.value.length;
        }else{
            box.dataset.prev = box.value;                      // store good state
        }

        /* live counter (optional) */
        const left = MAX_LINES - pageLines(box.value);
        editor.pageLbl.textContent =
            `Page ${editor.state.idx+1} – ${left} lines left`;
        updatePreview();
    }
    editor.pageBox.addEventListener('input', enforceLimit);

    function parseTokens(text){
        const def = {color:'#ffffff', bold:false, italic:false, underline:false, strike:false};
        const style = {...def};
        const t=[];
        for(let i=0;i<text.length;i++){
            const ch=text[i];
            if(ch==='§' && i+1<text.length){
                const code=text[i+1].toLowerCase();
                if(MC_COL[code]){ style.color=MC_COL[code]; style.bold=style.italic=style.underline=style.strike=false; }
                else if(code==='l') style.bold=true;
                else if(code==='o') style.italic=true;
                else if(code==='n') style.underline=true;
                else if(code==='m') style.strike=true;
                else if(code==='r') Object.assign(style, def);
                i++; continue;
            }
            t.push({ch, style:{...style}});
        }
        return t;
    }

    function tokensWidth(arr){
        let w=0; arr.forEach(t=>{ if(t.ch!=="\n") w+=glyphPx(t.ch,t.style.bold); }); return w; }

    function wrapTokens(tokens){
        const lines=[[]];
        let px=0, lastSpace=-1;
        for(let i=0;i<tokens.length;i++){
            const t=tokens[i];
            if(t.ch==='\n'){ lines.push([]); px=0; lastSpace=-1; continue; }
            const w=glyphPx(t.ch,t.style.bold);
            if(px+w>LINE_PX){
                if(lastSpace>=0){
                    const move=lines[lines.length-1].splice(lastSpace+1);
                    move.push(t);
                    lines.push(move);
                    px=tokensWidth(move);
                    lastSpace=-1;
                }else{
                    lines.push([t]);
                    px=w;
                }
            }else{
                lines[lines.length-1].push(t);
                px+=w;
            }
            if(t.ch===' ') lastSpace=lines[lines.length-1].length-1;
        }
        return lines;
    }

    function styleEq(a,b){
        return a.color===b.color && a.bold===b.bold && a.italic===b.italic && a.underline===b.underline && a.strike===b.strike;
    }
    function styleStr(s){
        let st=`color:${s.color};`;
        if(s.bold) st+='font-weight:bold;';
        if(s.italic) st+='font-style:italic;';
        const deco=[]; if(s.underline) deco.push('underline'); if(s.strike) deco.push('line-through');
        if(deco.length) st+=`text-decoration:${deco.join(' ')};`;
        return st;
    }

    function renderLines(lines){
        let html='';
        lines.forEach((line,idx)=>{
            let cur=null;
            line.forEach(tok=>{
                if(!cur || !styleEq(cur,tok.style)){ if(cur) html+='</span>'; html+=`<span style="${styleStr(tok.style)}">`; cur=tok.style; }
                const c=tok.ch;
                if(c===' ') html+='&nbsp;'; else html+=c.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
            });
            if(cur) html+='</span>';
            if(idx<lines.length-1) html+='<br>';
        });
        return html;
    }

    function updatePreview(){
        const tokens=parseTokens(editor.pageBox.value);
        const lines=wrapTokens(tokens);
        editor.preview.innerHTML=renderLines(lines);
    }

    /* helper – load current page into textarea */
    function showCurrentPage(){
        const {pages, idx} = editor.state;
        if(pages.length===0) pages.push('');
        editor.pageBox.value = pages[idx];
        editor.pageLbl.textContent = `Page ${idx+1} / ${pages.length}`;
        updatePreview();
    }

    /* page navigation */
    editor.prevBtn.onclick = ()=>{ if(editor.state.idx>0){savePage(); editor.state.idx--; showCurrentPage();}};
    editor.nextBtn.onclick = ()=>{
        savePage();
        if(editor.state.idx<editor.state.pages.length-1){
            editor.state.idx++;
        }else{
            editor.state.pages.push('');
            editor.state.idx = editor.state.pages.length-1;
        }
        showCurrentPage();
    };

    /* write back edited textarea before changing page / saving */
    function savePage(){ editor.state.pages[editor.state.idx] = editor.pageBox.value; }

    /* formatting buttons & colour picker */
    editor.toolbar.querySelectorAll('button[data-code]').forEach(btn=>{
        btn.onclick = ()=> insertCode(btn.dataset.code);
    });
    editor.colorPick.onchange = e=>{ if(e.target.value) insertCode(e.target.value); e.target.value=''; };

    function insertCode(code){
        const box = editor.pageBox;
        const start = box.selectionStart, end = box.selectionEnd;
        box.setRangeText(code, start, end, 'end');
        box.focus();
        enforceLimit();
    }

    /* close overlay */
    editor.close.onclick = ()=> editor.overlay.style.display = 'none';

    /* SAVE â†’ call the same backend endpoints already used by showEditForm */
    editor.saveBtn.onclick = async ()=>{
        savePage();
        enforceLimit();
        if (pageLines(editor.pageBox.value) > MAX_LINES) {
            alert('This page is too long (exceeds 14 rendered lines). Shorten it before saving.');
            return;
        }
        const bodyCommon = {
            title : editor.title.value,
            author: editor.author.value,
            pages : editor.state.pages
        };
        let url, payload;
        if(editor.state.type==='bookshelf'){
            url = '/api/bookshelf/book/edit';
            payload = { ...editor.state.location, slot: editor.state.slot, ...bodyCommon };
        }else{
            url = '/api/player/book/edit';
            payload = {
                playerName    : editor.state.location.playerName,
                inventoryType : editor.state.location.inventoryType,
                slot          : editor.state.slot,
                ...bodyCommon
            };
        }
        try{
            await postJson(url, payload);
            editor.overlay.style.display='none';
            /* refresh whichever list is open */
            if(editor.state.type==='bookshelf'){
                handleBookshelfRowClick(currentSelectedRow,true);
            }else{
                loadPlayerBooks(
                    editor.state.location.playerName,
                    editor.state.location.inventoryType,
                    editor.state.location.playerUuid,
                    editor.state.location.isOnline
                );
            }
        }catch(err){ alert('Save failed: '+err.message); }
    };




    // Initialize
    connectWebSocket();
    loadPlayers(); // Start with players tab active
</script>
<script type="module" src="js/live.js"></script>

</body>
</html>