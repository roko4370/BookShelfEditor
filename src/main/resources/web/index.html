<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Bookshelf Editor</title>
    <style>
        body { font-family: sans-serif; background-color: #2b2b2b; color: #dcdcdc; display: flex; gap: 20px; padding: 20px; margin: 0; }
        .panel { background-color: #3c3f41; border: 1px solid #555; border-radius: 8px; padding: 15px; box-sizing: border-box; display: flex; flex-direction: column; }
        #main-panel { flex: 1; min-width: 350px; }
        #detail-panel { flex: 2; }
        h1, h2 { border-bottom: 2px solid #555; padding-bottom: 5px; margin-top: 0; }
        .table-container { overflow-y: auto; flex-grow: 1; max-height: 500px; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #555; padding: 8px; text-align: left; }
        th { background-color: #45494a; position: sticky; top: 0; }
        tbody tr { cursor: pointer; }
        tbody tr:hover { background-color: #4a4e50; }
        tbody tr.selected { background-color: #0d6efd; color: white; }
        #status { margin-top: 10px; font-style: italic; color: #aaa; flex-shrink: 0; }
        #book-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; }
        #book-list li { background-color: #45494a; margin-bottom: 10px; border-radius: 5px; padding: 10px; position: relative; }
        .book-title { cursor: pointer; font-weight: bold; color: #58a6ff; }
        .book-title:hover { text-decoration: underline; }
        .book-content { display: none; margin-top: 10px; padding: 10px; background-color: #2b2b2b; border-radius: 4px; white-space: pre-wrap; max-height: 300px; overflow-y: auto; border: 1px solid #555; }
        .tab-container { display: flex; margin-bottom: 15px; }
        .tab { padding: 10px 20px; background-color: #45494a; border: 1px solid #555; cursor: pointer; margin-right: 5px; border-radius: 4px 4px 0 0; }
        .tab.active { background-color: #0d6efd; color: white; }
        .tab-content { display: none; }
        .tab-content.active { display: flex; flex-direction: column; flex-grow: 1; }
        .search-box { width: 100%; padding: 8px; margin-bottom: 10px; background-color: #2b2b2b; border: 1px solid #555; color: #dcdcdc; border-radius: 4px; }
        .inventory-type-selector { margin-bottom: 10px; }
        .inventory-type-selector label { margin-right: 15px; }
        .player-info { background-color: #45494a; padding: 10px; border-radius: 4px; margin-bottom: 10px; }
        .online-indicator { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 5px; }
        .online { background-color: #28a745; }
        .offline { background-color: #dc3545; }
        .connection-status { position: fixed; top: 10px; right: 10px; padding: 5px 10px; border-radius: 4px; font-size: 12px; }
        .connected { background-color: #28a745; color: white; }
        .disconnected { background-color: #dc3545; color: white; }
        .reconnecting { background-color: #ffc107; color: black; }
        .last-seen { font-size: 0.8em; color: #aaa; }

        /* NEW/MODIFIED STYLES FOR EDITING */
        .edit-btn { position: absolute; top: 10px; right: 10px; padding: 4px 8px; font-size: 12px; background-color: #58a6ff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        .edit-btn:hover { background-color: #2986e2; }
        .edit-form { margin-top: 10px; display: flex; flex-direction: column; gap: 10px; }
        .edit-form input, .edit-form textarea { width: 100%; box-sizing: border-box; padding: 8px; background-color: #2b2b2b; border: 1px solid #555; color: #dcdcdc; border-radius: 4px; }
        .edit-form textarea { min-height: 200px; resize: vertical; }
        .edit-form-actions { display: flex; gap: 10px; justify-content: flex-end; }
        .edit-form-actions button { padding: 6px 12px; border: none; border-radius: 4px; cursor: pointer; }
        .save-btn { background-color: #28a745; color: white; }
        .save-btn:hover { background-color: #218838; }
        .cancel-btn { background-color: #6c757d; color: white; }
        .cancel-btn:hover { background-color: #5a6268; }
        .edit-status { font-size: 0.9em; color: #ffc107; }
    </style>
</head>
<body>

<div class="connection-status reconnecting" id="connection-status">Connecting...</div>

<div id="main-panel" class="panel">
    <h1>Book Browser</h1>

    <div class="tab-container">
        <div class="tab active" data-tab="players">Players</div>
        <div class="tab" data-tab="bookshelves">Bookshelves</div>
        <div class="tab" data-tab="all-books">All Books</div>
    </div>

    <!-- Players Tab -->
    <div id="players-tab" class="tab-content active">
        <h2>Player List</h2>
        <input type="text" id="player-search" class="search-box" placeholder="Search for player...">
        <div class="inventory-type-selector">
            <label><input type="radio" name="inventory-type" value="INVENTORY" checked> Inventory</label>
            <label><input type="radio" name="inventory-type" value="ENDERCHEST"> Ender Chest</label>
        </div>
        <div class="table-container">
            <table id="player-table">
                <thead>
                <tr><th>Player</th><th>Status</th><th>Last Seen</th></tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
        <div id="player-status">Loading players...</div>
    </div>

    <!-- Bookshelves Tab -->
    <div id="bookshelves-tab" class="tab-content">
        <h2>Chiseled Bookshelves</h2>
        <div class="table-container">
            <table id="bookshelf-table">
                <thead>
                <tr><th>World</th><th>X</th><th>Y</th><th>Z</th></tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
        <div id="bookshelf-status">Loading...</div>
    </div>

    <!-- All Books Tab -->
    <div id="all-books-tab" class="tab-content">
        <h2>All Books</h2>
        <input type="text" id="all-books-search" class="search-box" placeholder="Search books by title, author, or player...">
        <div class="table-container">
            <table id="all-books-table">
                <thead>
                <tr><th>Player</th><th>Status</th><th>Title</th><th>Author</th><th>Location</th></tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
        <div id="all-books-status">Loading...</div>
    </div>
</div>

<div id="detail-panel" class="panel">
    <h2 id="detail-header">Select an item to view details</h2>
    <ul id="book-list"></ul>
</div>

<script>
    // Global variables
    const connectionStatus = document.getElementById('connection-status');
    const detailHeader = document.getElementById('detail-header');
    const bookList = document.getElementById('book-list');
    let currentSelectedRow = null;
    let socket = null;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5;

    // Player functionality
    const playerSearch = document.getElementById('player-search');
    const playerTableBody = document.querySelector("#player-table tbody");
    const playerStatus = document.querySelector("#player-status");

    // Bookshelf functionality
    const bookshelfTableBody = document.querySelector("#bookshelf-table tbody");
    const bookshelfStatus = document.querySelector("#bookshelf-status");

    // All books functionality
    const allBooksSearch = document.getElementById('all-books-search');
    const allBooksTableBody = document.querySelector("#all-books-table tbody");
    const allBooksStatus = document.querySelector("#all-books-status");

    let allPlayers = [];
    let allBooks = [];

    // Tab functionality
    document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
            const tabName = tab.dataset.tab;
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            tab.classList.add('active');
            document.getElementById(tabName + '-tab').classList.add('active');
            switch(tabName) {
                case 'players': loadPlayers(); break;
                case 'bookshelves': loadBookshelves(); break;
                case 'all-books': loadAllBooks(); break;
            }
        });
    });

    // WebSocket functionality
    function connectWebSocket() {
        if (socket && socket.readyState === WebSocket.OPEN) return;
        updateConnectionStatus('reconnecting', 'Connecting...');
        socket = new WebSocket(`ws://${window.location.host}/api/live-updates`);
        socket.onopen = () => {
            console.log("WebSocket connection established.");
            updateConnectionStatus('connected', 'Connected');
            reconnectAttempts = 0;
        };
        socket.onmessage = (event) => {
            try {
                const msg = JSON.parse(event.data);
                handleWebSocketMessage(msg);
            } catch (e) {
                console.error("Error parsing WebSocket message:", e);
            }
        };
        socket.onclose = () => {
            console.log("WebSocket connection closed.");
            updateConnectionStatus('disconnected', 'Disconnected');
            if (reconnectAttempts < maxReconnectAttempts) {
                reconnectAttempts++;
                updateConnectionStatus('reconnecting', `Reconnecting... (${reconnectAttempts}/${maxReconnectAttempts})`);
                setTimeout(connectWebSocket, 5000);
            } else {
                updateConnectionStatus('disconnected', 'Connection Failed');
            }
        };
        socket.onerror = (error) => {
            console.error("WebSocket error:", error);
            updateConnectionStatus('disconnected', 'Connection Error');
        };
    }

    function updateConnectionStatus(status, text) {
        connectionStatus.className = `connection-status ${status}`;
        connectionStatus.textContent = text;
    }

    function handleWebSocketMessage(msg) {
        switch (msg.type) {
            case 'bookshelf-added':
                addBookshelfTableRow(msg.data);
                sortBookshelfTable();
                updateBookshelfStatusText();
                break;
            case 'bookshelf-removed':
                removeBookshelfRow(msg.data);
                break;
            case 'bookshelf-updated':
                handleBookshelfUpdate(msg.data);
                break;
            case 'player-status-updated':
            case 'player-list-updated':
                loadPlayers(); // For simplicity, just reload players on any player update
                break;
            case 'player-book-updated':
                handlePlayerBookUpdate(msg.data);
                break;
        }
    }

    // Player functionality
    async function loadPlayers() {
        playerStatus.textContent = 'Loading players...';
        try {
            const response = await fetch('/api/players');
            const players = await response.json();
            allPlayers = players;
            displayPlayers(players);
            playerStatus.textContent = `Loaded ${players.length} players`;
        } catch (error) {
            playerStatus.textContent = `Error loading players: ${error.message}`;
        }
    }

    function displayPlayers(players) {
        playerTableBody.innerHTML = '';
        players.forEach(player => {
            const row = playerTableBody.insertRow();
            row.dataset.playerName = player.name;
            row.dataset.playerUuid = player.uuid;
            const onlineStatus = player.online ? 'Online' : 'Offline';
            const lastSeen = player.online ? 'Now' : formatLastSeen(player.lastSeen);
            row.innerHTML = `<td>${player.name}</td><td><span class="online-indicator ${player.online ? 'online' : 'offline'}"></span>${onlineStatus}</td><td class="last-seen">${lastSeen}</td>`;
            row.addEventListener('click', () => handlePlayerRowClick(player, row));
        });
    }

    function handlePlayerRowClick(player, row) {
        if (currentSelectedRow) currentSelectedRow.classList.remove('selected');
        row.classList.add('selected');
        currentSelectedRow = row;
        const inventoryType = document.querySelector('input[name="inventory-type"]:checked').value;
        loadPlayerBooks(player.name, inventoryType);
    }

    async function loadPlayerBooks(playerName, inventoryType) {
        detailHeader.textContent = `Loading ${playerName}'s ${inventoryType.toLowerCase()}...`;
        bookList.innerHTML = '<li>Loading books...</li>';
        try {
            const response = await fetch(`/api/player/books?player=${encodeURIComponent(playerName)}&type=${inventoryType}`);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const books = await response.json();
            detailHeader.textContent = `Books in ${playerName}'s ${inventoryType.charAt(0) + inventoryType.slice(1).toLowerCase()} (${books.length})`;
            displayBooks(books); // Player books are not editable, so no location is passed
        } catch (error) {
            detailHeader.textContent = `Error loading books for ${playerName}`;
            bookList.innerHTML = `<li>Error loading books: ${error.message}</li>`;
        }
    }

    async function handlePlayerBookUpdate(data) {
        if (currentSelectedRow && currentSelectedRow.dataset.playerName === data.playerName) {
            const inventoryType = document.querySelector('input[name="inventory-type"]:checked').value;
            await loadPlayerBooks(data.playerName, inventoryType);
        }
        if (document.querySelector('.tab[data-tab="all-books"]').classList.contains('active')) {
            await loadAllBooks();
        }
    }

    playerSearch.addEventListener('input', debounce(() => {
        const searchTerm = playerSearch.value.toLowerCase();
        const filteredPlayers = allPlayers.filter(p => p.name.toLowerCase().includes(searchTerm));
        displayPlayers(filteredPlayers);
        playerStatus.textContent = `Showing ${filteredPlayers.length} of ${allPlayers.length} players`;
    }, 300));

    document.querySelectorAll('input[name="inventory-type"]').forEach(radio => {
        radio.addEventListener('change', () => {
            if (currentSelectedRow && currentSelectedRow.dataset.playerName) {
                const playerName = currentSelectedRow.dataset.playerName;
                const inventoryType = document.querySelector('input[name="inventory-type"]:checked').value;
                loadPlayerBooks(playerName, inventoryType);
            }
        });
    });

    // Bookshelf functionality
    async function loadBookshelves() {
        try {
            const response = await fetch('/api/bookshelves');
            const data = await response.json();
            bookshelfTableBody.innerHTML = '';
            data.forEach(addBookshelfTableRow);
            sortBookshelfTable();
            updateBookshelfStatusText();
        } catch (error) {
            bookshelfStatus.textContent = `Error fetching bookshelf list: ${error.message}`;
        }
    }

    function addBookshelfTableRow(shelf) {
        const row = bookshelfTableBody.insertRow();
        row.id = `shelf-${shelf.world}-${shelf.x}-${shelf.y}-${shelf.z}`;
        row.innerHTML = `<td>${shelf.world}</td><td>${shelf.x}</td><td>${shelf.y}</td><td>${shelf.z}</td>`;
        row.dataset.world = shelf.world;
        row.dataset.x = shelf.x;
        row.dataset.y = shelf.y;
        row.dataset.z = shelf.z;
        row.addEventListener('click', () => handleBookshelfRowClick(row));
    }

    function sortBookshelfTable() {
        const rows = Array.from(bookshelfTableBody.querySelectorAll('tr'));
        rows.sort((a, b) => {
            const dsA = a.dataset, dsB = b.dataset;
            return dsA.world.localeCompare(dsB.world) || dsA.x - dsB.x || dsA.y - dsB.y || dsA.z - dsB.z;
        });
        rows.forEach(row => bookshelfTableBody.appendChild(row));
    }

    function updateBookshelfStatusText() {
        bookshelfStatus.textContent = `Showing ${bookshelfTableBody.rows.length} bookshelves`;
    }

    async function handleBookshelfRowClick(row, isAutoUpdate = false) {
        if (!isAutoUpdate) {
            if (currentSelectedRow) currentSelectedRow.classList.remove('selected');
            row.classList.add('selected');
            currentSelectedRow = row;
        }
        const { world, x, y, z } = row.dataset;
        detailHeader.textContent = `Books in Bookshelf [${world}, ${x}, ${y}, ${z}]`;
        await loadBookshelfBooks({ world, x, y, z });
    }

    async function loadBookshelfBooks(location) {
        bookList.innerHTML = '<li>Loading books...</li>';
        try {
            const { world, x, y, z } = location;
            const response = await fetch(`/api/bookshelf?world=${world}&x=${x}&y=${y}&z=${z}`);
            if (!response.ok) throw new Error((await response.json()).error || `HTTP error! status: ${response.status}`);
            const books = await response.json();
            displayBooks(books, location); // Pass location to enable editing
        } catch (error) {
            bookList.innerHTML = `<li>Error loading books: ${error.message}</li>`;
        }
    }

    function removeBookshelfRow(shelf) {
        const rowId = `shelf-${shelf.world}-${shelf.x}-${shelf.y}-${shelf.z}`;
        const rowToRemove = document.getElementById(rowId);
        if (rowToRemove) {
            if (rowToRemove === currentSelectedRow) {
                currentSelectedRow = null;
                detailHeader.textContent = 'Select an item to view details';
                bookList.innerHTML = '';
            }
            rowToRemove.remove();
            updateBookshelfStatusText();
        }
    }

    function handleBookshelfUpdate(data) {
        if (currentSelectedRow && currentSelectedRow.dataset.world === data.world &&
            currentSelectedRow.dataset.x == data.x &&
            currentSelectedRow.dataset.y == data.y &&
            currentSelectedRow.dataset.z == data.z) {
            handleBookshelfRowClick(currentSelectedRow, true);
        }
    }

    // All books functionality
    async function loadAllBooks() {
        allBooksStatus.textContent = 'Loading all books...';
        allBooksTableBody.innerHTML = '';
        try {
            const response = await fetch('/api/books/all');
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const books = await response.json();
            allBooks = books;
            displayAllBooks(books);
            allBooksStatus.textContent = `Found ${books.length} book(s) across all players`;
        } catch (error) {
            allBooksStatus.textContent = `Error loading books: ${error.message}`;
        }
    }

    function displayAllBooks(books) {
        allBooksTableBody.innerHTML = '';
        books.forEach(book => {
            const row = allBooksTableBody.insertRow();
            row.innerHTML = `<td>${book.playerName}</td><td><span class="online-indicator ${book.online ? 'online' : 'offline'}"></span>${book.online ? 'Online' : 'Offline'}</td><td>${book.title || 'Untitled'}</td><td>${book.author || 'Unknown'}</td><td>${book.inventoryType} Slot ${book.slot}</td>`;
            row.addEventListener('click', () => {
                if (currentSelectedRow) currentSelectedRow.classList.remove('selected');
                row.classList.add('selected');
                currentSelectedRow = row;
                detailHeader.textContent = `"${book.title || 'Untitled'}" by ${book.author || 'Unknown'}`;
                displayBooks([book]); // Not editable from this view
            });
        });
    }

    allBooksSearch.addEventListener('input', debounce(() => {
        const searchTerm = allBooksSearch.value.toLowerCase();
        const filteredBooks = allBooks.filter(book => book.playerName.toLowerCase().includes(searchTerm) || (book.title && book.title.toLowerCase().includes(searchTerm)) || (book.author && book.author.toLowerCase().includes(searchTerm)));
        displayAllBooks(filteredBooks);
        allBooksStatus.textContent = `Showing ${filteredBooks.length} of ${allBooks.length} books`;
    }, 300));


    // *** NEW/MODIFIED BOOK DISPLAY AND EDITING LOGIC ***

    function displayBooks(books, bookshelfLocation = null) {
        bookList.innerHTML = '';
        if (books.length === 0) {
            bookList.innerHTML = '<li>No books found.</li>';
            return;
        }

        books.forEach(book => {
            const li = document.createElement('li');
            li.dataset.slot = book.slot; // Store slot for editing

            const bookDisplay = document.createElement('div');
            bookDisplay.className = 'book-display';
            bookDisplay.innerHTML = `<span class="book-title"></span> by <em></em> (Slot: ${book.slot})<div class="book-content"></div>`;

            const titleEl = bookDisplay.querySelector('.book-title');
            const authorEl = bookDisplay.querySelector('em');
            const contentEl = bookDisplay.querySelector('.book-content');

            titleEl.textContent = book.title || 'Untitled';
            authorEl.textContent = book.author || 'Unknown';
            contentEl.textContent = book.pages.join('\n\n');

            titleEl.addEventListener('click', (e) => {
                const content = e.target.closest('.book-display').querySelector('.book-content');
                content.style.display = content.style.display === 'block' ? 'none' : 'block';
            });

            li.appendChild(bookDisplay);

            if (bookshelfLocation) {
                const editButton = document.createElement('button');
                editButton.className = 'edit-btn';
                editButton.textContent = 'Edit';
                editButton.addEventListener('click', () => showEditForm(li, book, bookshelfLocation));
                li.appendChild(editButton);
            }

            bookList.appendChild(li);
        });
    }

    function showEditForm(li, book, location) {
        const bookDisplay = li.querySelector('.book-display');
        const editButton = li.querySelector('.edit-btn');
        bookDisplay.style.display = 'none';
        if(editButton) editButton.style.display = 'none';

        const form = document.createElement('form');
        form.className = 'edit-form';
        form.innerHTML = `
            <label>Title: <input type="text" name="title" value="${book.title || ''}"></label>
            <label>Author: <input type="text" name="author" value="${book.author || ''}"></label>
            <label>Pages (one page per line): <textarea name="pages">${book.pages.join('\n')}</textarea></label>
            <div class="edit-form-actions">
                <span class="edit-status"></span>
                <button type="button" class="cancel-btn">Cancel</button>
                <button type="submit" class="save-btn">Save</button>
            </div>
        `;

        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            const saveBtn = form.querySelector('.save-btn');
            const statusEl = form.querySelector('.edit-status');
            saveBtn.disabled = true;
            statusEl.textContent = 'Saving...';

            const formData = new FormData(form);
            const payload = {
                ...location,
                slot: book.slot,
                title: formData.get('title'),
                author: formData.get('author'),
                pages: formData.get('pages').split('\n')
            };

            try {
                const response = await fetch('/api/bookshelf/book/edit', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.error || 'Failed to save book.');
                }

                // On success, reload the bookshelf books to show changes
                await handleBookshelfRowClick(currentSelectedRow, true);

            } catch (error) {
                statusEl.textContent = `Error: ${error.message}`;
                saveBtn.disabled = false;
            }
        });

        form.querySelector('.cancel-btn').addEventListener('click', () => {
            form.remove();
            bookDisplay.style.display = 'block';
            if(editButton) editButton.style.display = 'block';
        });

        li.appendChild(form);
    }


    // Utility functions
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => { clearTimeout(timeout); func(...args); };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    function formatLastSeen(timestamp) {
        if (!timestamp) return 'Never';
        const now = Date.now();
        const diff = now - timestamp;
        const minutes = Math.floor(diff / 60000);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);
        if (minutes < 1) return 'Just now';
        if (minutes < 60) return `${minutes}m ago`;
        if (hours < 24) return `${hours}h ago`;
        return `${days}d ago`;
    }

    // Initialize
    connectWebSocket();
    loadPlayers(); // Start with players tab active
</script>

</body>
</html>